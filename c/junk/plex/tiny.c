static const char help[] =
"Build and view a tiny three-triangle mesh using DMPlex, and integrate a\n"
"scalar function over it.  Option prefixes tny_ and plex_view_.\n\n";

/* either build DMPlex via call to DMPlexCreateFromCellList()
    ./tiny
or by directly setting cones "by hand":
    ./tiny -tny_by_hand

compute an integral by symmetric Gauss quadrature:
    ./tiny -tny_integrate_f
    ./tiny -tny_integrate_f -tny_quaddegree 1|[2]|3

compare these views:
    ./tiny -dm_view
    ./tiny -section_view
    ./tiny -v_vec_view

and -plex_view_xxx options (see plexview.h)

parallel refinement works:
    mpiexec -n 2 ./tiny -dm_refine 1 -plex_view_ranges -plex_view_coords

FIXME interpolation of f(x,y) by P2

FIXME interpolate f(x,y) by P2 and integrate it

FIXME add option -tny_element P1|P2|P3
*/

#include <petsc.h>
#include "../../quadrature.h"
#include "plexview.h"

// Describe the mesh "triangle style" with separate numbering for cells and vertices.
static const int    dim = 2,
                    ncell = 3,
                    nvert = 5,
                    cells[9] = {0, 3, 2,  // 9 = ncell * (dim+1)
                                0, 2, 1,
                                2, 3, 4};
static const double coordverts[10] = {0.0, 0.0,  // 10 = nvert * dim
                                      0.0, 1.0,
                                      0.5, 1.0,
                                      1.0, 0.0,
                                      1.0, 1.0};

// Describe same mesh, but directly as DMPlex, i.e. by giving cell and
// edge cones in DAG.  These values are generated by DMPlexCreateFromCellList()
// internally, so they are redundant if we use that create method.
static const int npoint = 15,
                 ccone[3][3] = {{8,9,10},
                                {10,11,12},
                                {9,13,14}},
                 econe[7][2] = {{3,6},
                                {5,6},
                                {3,5},
                                {4,5},
                                {3,4},
                                {6,7},
                                {5,7}};

static double f(double x, double y) {
    return exp(- x - 2 * y);
}

extern PetscErrorCode CreateMeshByHand(DM*);
extern PetscErrorCode CreateCoordinateSectionByHand(DM*);
extern PetscErrorCode CreateSectionP2(DM,PetscSection*);
extern PetscErrorCode IntegrateF(DM,double(double,double),int,double*);
extern PetscErrorCode EvaluateFP2(DM,PetscSection,double(double,double),Vec*);

int main(int argc,char **argv) {
    PetscErrorCode ierr;
    DM            dmplex;
    PetscSection  p2section;
    Vec           v;
    PetscBool     by_hand = PETSC_FALSE,
                  integrate_f = PETSC_FALSE;
    int           quaddegree = 2;

    PetscInitialize(&argc,&argv,NULL,help);
    ierr = PetscOptionsBegin(PETSC_COMM_WORLD, "tny_", "options for tiny", "");CHKERRQ(ierr);
    ierr = PetscOptionsBool("-by_hand",
        "use by-hand construction",
        "tiny.c", by_hand, &by_hand, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsBool("-integrate_f",
        "integrate f(x,y) by summing over cells and using quadrature",
        "tiny.c", integrate_f, &integrate_f, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsInt("-quaddegree",
        "use this quadrature degree for numerical integrations",
        "tiny.c", quaddegree, &quaddegree, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsEnd();

    // create the DMPlex mesh
    if (by_hand) {
        ierr = CreateMeshByHand(&dmplex); CHKERRQ(ierr);
        ierr = CreateCoordinateSectionByHand(&dmplex); CHKERRQ(ierr);
    } else {
        PetscMPIInt rank;
        ierr = MPI_Comm_rank(PETSC_COMM_WORLD, &rank); CHKERRQ(ierr);
        if (rank == 0) { // create mesh on rank 0
            ierr = DMPlexCreateFromCellList(PETSC_COMM_WORLD,
                dim,ncell,nvert,dim+1,
                PETSC_TRUE,  // "interpolate" flag; TRUE means "topologically-interpolate"
                             // i.e. create edges (1D) from vertices (0D) and cells (2D)
                cells,dim,coordverts,
                &dmplex); CHKERRQ(ierr);
        } else { // empty mesh on rank > 0
            ierr = DMPlexCreateFromCellList(PETSC_COMM_WORLD,
                dim,0,0,dim+1,PETSC_TRUE,NULL,dim,NULL,&dmplex); CHKERRQ(ierr);
        }
    }

    // distribute mesh over processes using default partitioner
    {
        DM  distributedMesh = NULL;
        // overlap of 0 is appropriate to P2 etc. FEM:
        ierr = DMPlexDistribute(dmplex, 0, NULL, &distributedMesh);CHKERRQ(ierr);
        if (distributedMesh) {
          ierr = DMDestroy(&dmplex);CHKERRQ(ierr);
          dmplex  = distributedMesh;
        }
    }

    // reset names before viewing
    ierr = PetscObjectSetName((PetscObject)dmplex, "tiny mesh"); CHKERRQ(ierr);
    {
        DM           cdm;
        PetscSection csection;
        ierr = DMGetCoordinateDM(dmplex, &cdm); CHKERRQ(ierr);
        ierr = DMGetDefaultSection(cdm, &csection); CHKERRQ(ierr);
        ierr = PetscObjectSetName((PetscObject)csection, "vertex coordinate section"); CHKERRQ(ierr);
    }
    ierr = DMSetFromOptions(dmplex); CHKERRQ(ierr);
    ierr = DMViewFromOptions(dmplex, NULL, "-dm_view"); CHKERRQ(ierr);
    ierr = PlexViewFromOptions(dmplex); CHKERRQ(ierr);

    // integrate f(x,y) by summing over cells and using quadrature
    if (integrate_f) {
        double       integral;
        const double intfexact = (1.0 - exp(-1.0)) * 0.5 * (1.0 - exp (-2.0));
        ierr = IntegrateF(dmplex,f,quaddegree,&integral); CHKERRQ(ierr);
        ierr = PetscPrintf(PETSC_COMM_WORLD,
            "integral of f(x,y) is %.12f with error %.2e\n",
            integral,fabs(integral - intfexact)); CHKERRQ(ierr);
    }

    // create nodes (degrees of freedom) for P2 elements using PetscSection
    ierr = CreateSectionP2(dmplex,&p2section); CHKERRQ(ierr);
    ierr = DMSetDefaultSection(dmplex, p2section); CHKERRQ(ierr);
    ierr = PetscObjectViewFromOptions((PetscObject)p2section,NULL,"-tny_view_section"); CHKERRQ(ierr);

    // put function f(x,y) into v by local calculations using coordinates and p2section
    ierr = DMCreateGlobalVector(dmplex, &v); CHKERRQ(ierr);
    ierr = PetscObjectSetName((PetscObject)v, "v"); CHKERRQ(ierr);
    ierr = EvaluateFP2(dmplex,p2section,f,&v); CHKERRQ(ierr);
    ierr = PetscObjectViewFromOptions((PetscObject)v,NULL,"-v_vec_view"); CHKERRQ(ierr);

    VecDestroy(&v);  PetscSectionDestroy(&p2section);  DMDestroy(&dmplex);
    return PetscFinalize();
}

/* This function is essentially equivalent to using DMPlexCreateFromCellList().
Note that rank 0 gets the actual mesh and other ranks get an empty mesh.
See the implementations of
    DMPlexBuildFromCellList_Private()
    DMPlexCreateFromCellListParallel()
    DMPlexInterpolate()
    DMPlexBuildCoordinates_Private()      */
PetscErrorCode CreateMeshByHand(DM *dmplex) {
    PetscErrorCode ierr;
    int           j;
    PetscMPIInt   rank;
    ierr = MPI_Comm_rank(PETSC_COMM_WORLD,&rank); CHKERRQ(ierr);
    ierr = DMPlexCreate(PETSC_COMM_WORLD,dmplex); CHKERRQ(ierr);
    ierr = DMSetDimension(*dmplex,dim); CHKERRQ(ierr);
    if (rank == 0) {
        // set the total number of points (npoint = ncell + nvert + nedges)
        ierr = DMPlexSetChart(*dmplex, 0, npoint); CHKERRQ(ierr);
        // the points are cells, vertices, edges in that order
        // we only set cones for cells and edges
        for (j = 0; j < ncell; j++) {
            ierr = DMPlexSetConeSize(*dmplex, j, dim+1); CHKERRQ(ierr);
        }
        for (j = ncell + nvert; j < npoint; j++) {
            ierr = DMPlexSetConeSize(*dmplex, j, dim); CHKERRQ(ierr);
        }
        ierr = DMSetUp(*dmplex);
        for (j = 0; j < ncell; j++) {
            ierr = DMPlexSetCone(*dmplex, j, ccone[j]); CHKERRQ(ierr);
        }
        for (j = ncell + nvert; j < npoint; j++) {
            ierr = DMPlexSetCone(*dmplex, j, econe[j-ncell-nvert]); CHKERRQ(ierr);
        }
    } else {
        ierr = DMPlexSetChart(*dmplex, 0, 0); CHKERRQ(ierr);
    }
    // with cones we have only upward directions and no labels for the strata
    // (note: both Symmetrize & Stratify are required, and they must be in this order
    ierr = DMPlexSymmetrize(*dmplex); CHKERRQ(ierr);
    ierr = DMPlexStratify(*dmplex); CHKERRQ(ierr);
    return 0;
}

// Set up a PetscSection which holds vertex coordinates.
PetscErrorCode CreateCoordinateSectionByHand(DM *dmplex) {
    PetscErrorCode ierr;
    PetscSection  coordSection;
    DM            cdm;
    Vec           coordinates;
    double        *acoord;
    int           j, d, dim, vertexstart, vertexend;
    // you have to setup the PetscSection returned by DMGetCoordinateSection() first,
    // or else the Vec returned by DMCreateLocalVector() has zero size
    // (and thus seg faults)
    ierr = DMGetDimension(*dmplex, &dim); CHKERRQ(ierr);
    ierr = DMGetCoordinateSection(*dmplex, &coordSection); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(*dmplex, 0, &vertexstart, &vertexend); CHKERRQ(ierr);
    ierr = PetscSectionSetNumFields(coordSection, 1); CHKERRQ(ierr);
    ierr = PetscSectionSetFieldComponents(coordSection, 0, dim); CHKERRQ(ierr);
    ierr = PetscSectionSetChart(coordSection, vertexstart, vertexend); CHKERRQ(ierr);
    for (j = vertexstart; j < vertexend; j++) {
        ierr = PetscSectionSetDof(coordSection, j, dim); CHKERRQ(ierr);
        ierr = PetscSectionSetFieldDof(coordSection, j, 0, dim); CHKERRQ(ierr);
    }
    ierr = PetscSectionSetUp(coordSection); CHKERRQ(ierr);
    // now we can actually set up the coordinate Vec
    ierr = DMGetCoordinateDM(*dmplex, &cdm); CHKERRQ(ierr);
    ierr = DMCreateLocalVector(cdm, &coordinates); CHKERRQ(ierr);
    ierr = VecSetBlockSize(coordinates,dim); CHKERRQ(ierr);
    ierr = PetscObjectSetName((PetscObject) coordinates, "coordinates"); CHKERRQ(ierr);
    ierr = VecGetArray(coordinates, &acoord); CHKERRQ(ierr);
    for (j = 0; j < vertexend-vertexstart; j++) {
        for (d = 0; d < dim; ++d) {
            acoord[j*dim+d] = coordverts[j*dim+d];
        }
    }
    ierr = VecRestoreArray(coordinates, &acoord); CHKERRQ(ierr);
    // finally we tell the DM that it has coordinates
    ierr = DMSetCoordinatesLocal(*dmplex, coordinates); CHKERRQ(ierr);
    VecDestroy(&coordinates);
    return 0;
}

// use quadrature to integrate a function by summing over cells
PetscErrorCode IntegrateF(DM dmplex, double f(double x,double y),
                          int quaddegree, double *fint) {
    PetscErrorCode ierr;
    DM              cdm;
    Vec             coords;
    const Quad2DTri q = symmgauss[quaddegree-1];
    const double    *acoords;
    double          x[3], y[3], xr, yr, dx1, dx2, dy1, dy2, absdetJ,
                    csum, fintloc;
    int             numpts, *pts = NULL, voff, j, p, l, r,
                    vertstart, vertend, cellstart, cellend;
    MPI_Comm        comm;

    ierr = DMGetCoordinateDM(dmplex, &cdm); CHKERRQ(ierr);
    ierr = DMGetCoordinatesLocal(dmplex, &coords); CHKERRQ(ierr);
    ierr = DMPlexGetHeightStratum(dmplex, 0, &cellstart, &cellend); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(dmplex, 0, &vertstart, &vertend); CHKERRQ(ierr);
    ierr = VecGetArrayRead(coords, &acoords); CHKERRQ(ierr);
    // integral by sum over cells
    fintloc = 0.0;
    for (j = cellstart; j < cellend; j++) {
        ierr = DMPlexGetTransitiveClosure(dmplex, j, PETSC_TRUE, &numpts, &pts);
        if (numpts != 7) {
            SETERRQ(PETSC_COMM_WORLD,1,"wrong: assume closure of triangle has 7 points\n");
        }
        // record vertex coordinates
        for (l = 0; l < 3; l++) { // loop through vertex points
            p = 8 + 2 * l; // p=0,1 are cell info; p=2,...,7 are edge info; omit orientations
            if ((pts[p] < vertstart) || (pts[p] >= vertend))  {
                SETERRQ(PETSC_COMM_WORLD,2,"wrong: pts[p] should be a vertex\n");
            }
            voff = pts[p] - vertstart;
            x[l] = acoords[2*voff+0];
            y[l] = acoords[2*voff+1];
        }
        // geometry of element (cell)
        dx1 = x[1] - x[0];
        dx2 = x[2] - x[0];
        dy1 = y[1] - y[0];
        dy2 = y[2] - y[0];
        absdetJ = fabs(dx1 * dy2 - dx2 * dy1);
        // sum over quadrature points on cell
        csum = 0.0;
        for (r = 0; r < q.n; r++) {
            xr = x[0] + dx1 * q.xi[r] + dx2 * q.eta[r];
            yr = y[0] + dy1 * q.xi[r] + dy2 * q.eta[r];
            csum += q.w[r] * f(xr,yr);
        }
        // add cell contribution
        fintloc += absdetJ * csum;
        ierr = DMPlexRestoreTransitiveClosure(dmplex, j, PETSC_TRUE, &numpts, &pts); CHKERRQ(ierr);
    }
    ierr = VecRestoreArrayRead(coords, &acoords); CHKERRQ(ierr);

    ierr = PetscObjectGetComm((PetscObject)dmplex,&comm); CHKERRQ(ierr);
    ierr = MPI_Allreduce(&fintloc,fint,1,MPI_DOUBLE,MPI_SUM,comm); CHKERRQ(ierr);
    return 0;
}

PetscErrorCode CreateSectionP2(DM dmplex, PetscSection *section) {
    PetscErrorCode ierr;
    int  j, pstart, pend, vertexstart, edgeend;
    ierr = PetscSectionCreate(PETSC_COMM_WORLD,section); CHKERRQ(ierr);
    ierr = PetscObjectSetName((PetscObject)*section, "P2 scalar section"); CHKERRQ(ierr);
    ierr = PetscSectionSetNumFields(*section, 1); CHKERRQ(ierr);
    ierr = DMPlexGetChart(dmplex, &pstart, &pend); CHKERRQ(ierr);
    ierr = PetscSectionSetChart(*section, pstart, pend); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(dmplex, 0, &vertexstart, NULL); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(dmplex, 1, NULL, &edgeend); CHKERRQ(ierr);
    for (j = pstart; j < pend; ++j) {
        if (j < vertexstart) {
            ierr = PetscSectionSetDof(*section, j, 0); CHKERRQ(ierr);
            ierr = PetscSectionSetFieldDof(*section, j, 0, 0); CHKERRQ(ierr);
        } else {
            ierr = PetscSectionSetDof(*section, j, 1); CHKERRQ(ierr);
            ierr = PetscSectionSetFieldDof(*section, j, 0, 1); CHKERRQ(ierr);
        }
    }
    ierr = PetscSectionSetUp(*section); CHKERRQ(ierr);
    return 0;
}

PetscErrorCode EvaluateFP2(DM dmplex, PetscSection section,
                                double f(double x,double y), Vec *v) {
    PetscErrorCode ierr;
    DM           cdm;
    Vec          vloc, coords;
    double       *avloc, x, y;
    const double *acoords;
    int          numpts, *pts = NULL, dof, off, j, p,
                 vertstart, vertend, edgestart, edgeend, cellstart, cellend;

    // we put values in a local vector, thus redundantly on overlap
    ierr = DMGetLocalVector(dmplex, &vloc); CHKERRQ(ierr);
    ierr = VecGetArray(vloc, &avloc); CHKERRQ(ierr);
    // need coordinates of P2 nodes (i.e. both vertices and edges)
    ierr = DMGetCoordinateDM(dmplex, &cdm); CHKERRQ(ierr);
    ierr = DMGetCoordinatesLocal(dmplex,&coords); CHKERRQ(ierr);
    ierr = DMPlexGetHeightStratum(dmplex, 0, &cellstart, &cellend); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(dmplex, 0, &vertstart, &vertend); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(dmplex, 1, &edgestart, &edgeend); CHKERRQ(ierr);
    ierr = VecGetArrayRead(coords, &acoords); CHKERRQ(ierr);
    for (j = cellstart; j < cellend; j++) {
        ierr = DMPlexGetTransitiveClosure(dmplex, j, PETSC_TRUE, &numpts, &pts);
        for (p = 0; p < numpts*2; p += 2) {   // omit orientations
            PetscSectionGetDof(section, pts[p], &dof);
            if (dof > 0) {
                // compute (x,y) for vertex or edge center from coords
                if (pts[p] < vertstart) {
                    SETERRQ(PETSC_COMM_WORLD,1,"cell center computation not implemented\n");
                } else if (pts[p] < edgestart) {
                    int voff;
                    voff = pts[p] - vertstart;
                    x = acoords[2*voff+0];
                    y = acoords[2*voff+1];
                } else { // pts[p] is an edge ...
                    const int *vpts;
                    int       voff[2];
                    ierr = DMPlexGetCone(dmplex, pts[p], &vpts); CHKERRQ(ierr);
                    voff[0] = vpts[0] - vertstart;
                    voff[1] = vpts[1] - vertstart;
                    x = 0.5 * (acoords[2*voff[0]+0] + acoords[2*voff[1]+0]);
                    y = 0.5 * (acoords[2*voff[0]+1] + acoords[2*voff[1]+1]);
                }
                // get index "off" into Vec vloc based on P2 scalar section
                PetscSectionGetOffset(section, pts[p], &off);
                avloc[off] = f(x,y);
            }
        }
        ierr = DMPlexRestoreTransitiveClosure(dmplex, j, PETSC_TRUE, &numpts, &pts); CHKERRQ(ierr);
    }
    ierr = VecRestoreArray(vloc, &avloc); CHKERRQ(ierr);
    ierr = VecRestoreArrayRead(coords, &acoords); CHKERRQ(ierr);

    // now we want v global, i.e. only values not duplicate ghosts
    ierr = DMLocalToGlobalBegin(dmplex,vloc,INSERT_VALUES,*v); CHKERRQ(ierr);
    ierr = DMLocalToGlobalEnd(dmplex,vloc,INSERT_VALUES,*v); CHKERRQ(ierr);
    ierr = DMRestoreLocalVector(dmplex, &vloc); CHKERRQ(ierr);
    return 0;
}

// FIXME InterpolateFP2()

